<!DOCTYPE html>

<html>
	<head>
		<title>Boris Dimitrov, 82066, Test 3</title>
		<meta charset="utf-8">
		
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<script src="three.min.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="StereoEffect.js"></script>
		<script src="vax.js"></script>
	</head>
	
	<body>
		<script>
			var COLOR_HOUSE_WALL = 'rgb(255, 255, 190)';
			var COLOR_HOUSE_ROOF = 'rgb(200, 80, 30)';
			var GROUND_Y = -10;
			var GROUND_THICKNESS = 4;
			var GROUND_LEVEL = GROUND_Y + GROUND_THICKNESS / 2;

			// Init stuff
			vaxInit(); // TODO: bring back this: vaxInitParallax();
			initCameraPosition();
			var control = initOrbitalNavigation()

			var ground = createGround();
			var house = createHouse();
			
			function animate( t )
			{
				control.update();
			}

			function initOrbitalNavigation()
			{
				var control = new THREE.OrbitControls( camera, renderer.domElement );
				control.minDistance = 50;
				control.maxDistance = 500;
				control.minPolarAngle = 0;
				control.maxPolarAngle = 1.7; 
				control.rotateSpeed = 0.3;
				control.enableDamping = true;
				control.dampingFactor = 0.1;
				control.enablePan = true;
				control.object.zoom = 3;
				control.object.updateProjectionMatrix();
				return control;
			}
			function initCameraPosition()
			{
				camera.position.set( -80, 50, 200 );
				camera.lookAt( new THREE.Vector3(0,0,0) );
			}

			function createGround()
			{
				var geometry = new THREE.BoxGeometry( 300, GROUND_THICKNESS, 300 ),
				material = new THREE.MeshPhongMaterial({color:'rgb(0, 255, 0)', shininess:100});
				var ground = new THREE.Mesh( geometry, material );
				ground.position.set( 0, GROUND_Y, 0 );
				ground.receiveShadow = true;
				scene.add(ground);
				return ground;
			}
			function createHouse()
			{
				var wallHeight = 25;
				var houseLength = 50;
				var houseWidth = 30;

				var house = new THREE.Group();
				createBaseWalls(house);
				createRoof(house);
				scene.add(house);
				return house;

				function createBaseWalls(house)
				{
					var thickness = 1;
					var onGroundY = GROUND_LEVEL + wallHeight/2;
					var wallGeometries = [
						new THREE.BoxGeometry( thickness, wallHeight, houseLength ),
						new THREE.BoxGeometry( houseWidth, wallHeight, thickness ),
						new THREE.BoxGeometry( thickness, wallHeight, houseLength ),
						new THREE.BoxGeometry( houseWidth, wallHeight, thickness )
					];
					var wallPositions = [
						new THREE.Vector3(-houseWidth/2 + thickness/2, onGroundY, 0),
						new THREE.Vector3(0, onGroundY, houseLength/2 - thickness/2),
						new THREE.Vector3(houseWidth/2 - thickness/2, onGroundY, 0),
						new THREE.Vector3(0, onGroundY, -houseLength/2 + thickness/2)
					];
					var wallMaterial = new THREE.MeshStandardMaterial( {color:COLOR_HOUSE_WALL} );
					for (var i = 0; i < wallGeometries.length; i++)
					{
						var wall = new THREE.Mesh(wallGeometries[i],wallMaterial);
						wall.position.set(wallPositions[i].x, wallPositions[i].y, wallPositions[i].z);
						wall.castShadow = true;
						house.add(wall);
					}
				}
				function createRoof(house)
				{
					var angle = Math.PI * 0.17;
					var length = houseLength + 2;
					var width = 20;
					var thickness = 1;
					var roofY =
						GROUND_LEVEL + wallHeight + (width * Math.sin(angle)) / 2
						- (width * Math.cos(angle) - houseWidth / 2) * Math.tan(angle)
						+ (thickness / Math.cos(angle)) / 2
					;

					var roofGeometries = [
						new THREE.BoxGeometry( width, thickness, length ),
						new THREE.BoxGeometry( width, thickness, length )
					];
					var roofPositions = [
						new THREE.Vector3((-width * Math.cos(angle)) / 2, roofY, 0),
						new THREE.Vector3((+width * Math.cos(angle)) / 2, roofY, 0)
					];
					var roofAngles = [ +angle, -angle];
					var roofMaterial = new THREE.MeshStandardMaterial( {color:COLOR_HOUSE_ROOF} );
					for (var i = 0; i < roofGeometries.length; i++)
					{
						var roofPart = new THREE.Mesh(roofGeometries[i], roofMaterial);
						roofPart.position.set(roofPositions[i].x, roofPositions[i].y, roofPositions[i].z);
						roofPart.rotation.z = roofAngles[i];
						roofPart.castShadow = true;
						house.add(roofPart);
					}
				}
			}
		</script>
	</body>
</html>


